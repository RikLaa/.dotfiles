"============================================================================
" Plugs
"============================================================================
" load all plugins from under .dotfiles
set rtp+=~/.dotfiles/vim
call plug#begin('~/.dotfiles/vim/bundle')

" General usability
Plug 'scrooloose/nerdtree', { 'on':  ['NERDTreeToggle', 'NERDTreeFind'] }
Plug 'tpope/vim-commentary'           " Comments
" Pug 'easymotion/vim-easymotion'
Plug 'tpope/vim-surround'             " Vim Surround plugin 
Plug 'jiangmiao/auto-pairs'           " Autoclose brackets
Plug 'alvan/vim-closetag'             " Close HTML, XML tags
" Plug 'valloric/matchtagalways'        " Matching xml tag

" Plug 'christoomey/vim-tmux-navigator' " Navigate vim and tmux panes more easily

" Git
Plug 'tpope/vim-fugitive'             " Git utility
Plug 'airblade/vim-gitgutter'         " Show git diffs on sidebar
Plug 'jreybert/vimagit'

" Languages
" Plug 'gabrielelana/vim-markdown'
" Plug 'othree/xml.vim'
Plug 'posva/vim-vue', {'for': 'vue'}
" Plug 'othree/html5.vim', {'for': 'html'}
Plug 'pangloss/vim-javascript', {'for': 'javascript'}
Plug 'mxw/vim-jsx', {'for': 'javascript'}
Plug 'alampros/vim-styled-jsx'
Plug 'jwalton512/vim-blade', {'for': 'blade'}
Plug 'StanAngeloff/php.vim', {'for': 'php'}

Plug 'junegunn/fzf'                   " fuzzy searc

" Lint, autocomplete, etc
Plug 'w0rp/ale'
Plug 'Shougo/deoplete.nvim', {'do': ':UpdateRemotePlugins'}
Plug 'roxma/nvim-yarp'
Plug 'roxma/vim-hug-neovim-rpc'
" needs global tern executable
Plug 'carlitux/deoplete-ternjs', {'for': 'javascript'}
Plug 'editorconfig/editorconfig-vim'

" run npm install in this directory
Plug 'ternjs/tern_for_vim', {'for': 'javascript', 'do': 'npm install'}

Plug 'roxma/LanguageServer-php-neovim', {'do': 'composer install && composer run-script parse-stubs'}

Plug 'ludovicchabant/vim-gutentags'

" Plug 'autozimu/LanguageClient-neovim', {
"     \ 'branch': 'next',
"     \ 'do': 'bash install.sh',
"     \ }


" Plug 'prabirshrestha/async.vim'
" Plug 'prabirshrestha/vim-lsp'
" Plug 'prabirshrestha/asyncomplete.vim'
" Plug 'prabirshrestha/asyncomplete-lsp.vim'

" Snippets
Plug 'SirVer/ultisnips'
" Plug 'honza/vim-snippets'             " Custom snippets

" Ui
" Plug 'vim-airline/vim-airline'        " Cool statusbar and info
"Plug 'ap/vim-css-color'

" Themes
Plug 'tomasiser/vim-code-dark'        "Theme based on visual studio code
Plug 'andreypopp/vim-colors-plain'
Plug 'joshdick/onedark.vim'
Plug 'morhetz/gruvbox'



"Plug 'file:///~/.dotfiles/vim/custom_snippets'
call plug#end()            " required

"============================================================================
"General
"============================================================================
set nocompatible            " no need to support vi
filetype plugin on
filetype indent on
set mouse=a                 " Use mouse
set rtp+=~/.local/bin       " Use executables (fzf) from bin
set path+=**                " Provide tab-completion for all file-related tasks
set autoread                " Reload files changed outside vim
set encoding=utf-8
set nowrap                  " Disable text wrapping"
set backspace=2             " Allow deleting in insert mode 
set scrolloff=8             " keep 8 lines of space above and below the cursor
set splitright              " Split new windows to the right"
set splitbelow              " Split horizontal new windows to the bottom"
" set backupcopy=no          " Doesnt with webpack-dev-server without this (if backups not on)?
set nobackup
set noswapfile              " Dont use swapfiles"
set hidden                  " Can change to another buffer without saving change"
set updatetime=500          " Shows gitgutter signs faster 
set timeout                 " Reduce timeout caused by pressin Esc"
set timeoutlen=3000
set ttimeout
set ttimeoutlen=50
set ttyfast                   "Smoother scrolling"
set lazyredraw              " "Smootherrrr.??

"============================================================================
" UI
"============================================================================
set number					" For line numbering
set wildmenu                " Display all matching files when we tab complete
" set ruler
set noruler
set nocursorline
" set relativenumber          " For relative line numbering
syntax enable				" Show syntax
set t_Co=256                " Enable 256 colors
" set t_ut=
" set termguicolors           " Better colors in terminal, needs support from tmux also
"
" colorscheme codedark		" Do not set termguicolors with this one
" colorscheme onedark
" colorscheme plain
colorscheme gruvbox
set background=dark    " Setting dark mode
set showcmd					" Show command at the bottom
set sidescroll=0            " Faster scrolling

"============================================================================
" Spaces & tab 
"============================================================================
set tabstop=4
set softtabstop=4
set shiftwidth=4			" When indenting with >
set expandtab				" When tabbing, insert (four) spaces

"============================================================================
"Searching
"============================================================================
set grepprg=rg\ --vimgrep    " Use ripgrep instad of grep"
set ignorecase              " When typing smallcase, search is case-insensitive"
set smartcase               " If any character is UPPER-case, search case-sensitive"
set hlsearch                " Highligth search 
set incsearch				" Search as characters are entered


"============================================================================
" Custom Functions
"============================================================================
function! ToggleJSFunctionSyntax()
    let currentLine=getline('.')

    " Check if this is older syntax
    if matchstr(currentLine, "function") == "function"

        " Check if assigned function
        if matchstr(currentLine, "=") == "="
            " Check if var is used, and change it to const
            if matchstr(currentLine, 'var') == "var"
                normal 0ceconst
            endif
            " Change to arrow syntax
            normal 0f=wdt(f)la=> 
        else
            " Not assigned to variable

            let l:functionWordPosition = matchstrpos(currentLine, "function")
            " execute '/\%'.line(".").'lfunction'
            " execute cursor(matchstrpos(currentLine, "function"))
            :call cursor(line("."), functionWordPosition[1] + 1)
            normal ciwconst
            normal f(i = 
            normal f)a =>

            let a:cursosPositionBeforeIndent = getpos(".")
            normal ==
            :call cursor(a:cursosPositionBeforeIndent[1], a:cursosPositionBeforeIndent[2])
        endif
    else
        " Arrow function

        " Check if assigned to variable, const fn = ()
        " The assignment will be removed, just use: function() 
        " TODO: better check
        if matchstr(currentLine, " = ") == " = "
            if matchstr(currentLine, 'const') == "const"  || matchstr(currentLine, 'let') == "let" 
                 normal 0cefunction
                 normal ==
            endif

            " normal 0cevar
            " normal 0f(ifunction
            normal f=hd3l
            normal f)ldf>

        else
            " Not assigned to variable
            normal 0f>F(ifunction
            normal f)ldf>
        endif

    endif

endfunction

" Adds inputted character to the end of the line without moving the cursor
function! AppendCharacterToEndOfLine()
    let a:cursor_pos_start = getpos(".")
    let c = nr2char(getchar())
    :execute "keepjumps normal! A".c

    " Move cursor back to original position
    call cursor(a:cursor_pos_start[1], a:cursor_pos_start[2])

endfunction

"============================================================================
"Keybindings, custom mappings
"============================================================================
let mapleader="\<Space>"	" Use space as leader key

"Easier copy and paste from system clipboard
nnoremap <leader>Y "*y
vnoremap <leader>Y "*y
nnoremap <leader>P "+p

" map <ScrollWheelUp> <C-Y>
" map <ScrollWheelDown> <C-E>

nnoremap <silent><leader>a :call AppendCharacterToEndOfLine()<cr>

" Save if changes
" noremap <Leader>s :update<CR>	"quicksave

function! ToggleNERDTree()
    let l:isNERDTreeFocused = exists("b:NERDTree")
    if isNERDTreeFocused == 0 && bufexists(expand('%'))
        :NERDTreeFind
    else
        :NERDTreeToggle
    endif
endfunction
nnoremap <leader>e :call ToggleNERDTree()<CR>

let g:UltiSnipsJumpForwardTrigger="<Tab>"
let g:UltiSnipsJumpBackwardTrigger="<S-Tab>"

" Grep from files (current pwd). Seachword is a string, no regex, which allows
" to search for any kind of string inside project
function! Grep(searchword)
    let globs = "-g '!node_modules' -g '!.git/' -g '!*.lock' -g '!vendor/' -g '!storage/debugbar' -g '!_ide_helper.php' "
    :execute "grep! -S --hidden ". globs . "-F " . '"' . a:searchword . '"'
    :execute "cw"
endfunction

function! GrepFromFiles(selection) 
    let name = input('Search for: ', a:selection)
    if name != ""
        :execute ":call Grep(name)"
    endif

:endfunction
nnoremap <leader>f :call GrepFromFiles("")<CR>
vnoremap <leader>f y :call GrepFromFiles(@")<CR>

" FZF
" function! Fzf()
"     " If pwd is git project, get only the files tracked by git, else use
"     " ripgrep to fetch files
"     call fzf#run({'source': 'git ls-files || rg --files . ', 'window': '30new','sink': 'e'})
" endfunction
" nnoremap <leader>p :call Fzf()<CR>
" nnoremap <leader>p :call fzf#run({'source': 'rg --files . ', 'window': '30new','sink': 'e', 'options': '--ansi --color=dark --preview="cat $FILE {}"'})<CR>
nnoremap <leader>p :call fzf#run({'source': 'rg --files . ', 'window': '30new','sink': 'e'})<CR>
vnoremap <leader>p :call SearchFilesByWord("<C-r><C-w>")<CR>

" Open buffer with FZF
" https://github.com/junegunn/fzf/wiki/Examples-(vim)
function! s:buflist()
  redir => ls
  silent ls
  redir END
  return split(ls, '\n')
endfunction

function! s:bufopen(e)
  execute 'buffer' matchstr(a:e, '^[ 0-9]*')
endfunction

nnoremap <silent> <leader>b :call fzf#run({
\   'source':  reverse(<sid>buflist()),
\   'sink':    function('<sid>bufopen'),
\   'options': '+m',
\   'down':    len(<sid>buflist()) + 2
\ })<CR>

nnoremap <C-`> :term<CR>
"For windows navigation
nnoremap <C-h> <C-w>h	
nnoremap <C-j> <C-w>j
nnoremap <C-k> <C-w>k
nnoremap <C-l> <C-w>l

" Move to the previous buffer with 
nnoremap <S-Tab>  :bp<CR>
" Move to the next buffer with 
nnoremap <Tab>    :bn<CR>
" Close buffer
nnoremap <leader>q  :bd<CR>
command Bda :%bdelete

function! DeleteAndCloseBuffer()
    let l:message = "Delete file: " . expand('%')
    let l:confirmation = confirm(message, "&Yes\n&No\n" )
    if confirmation == 1 | call delete(expand('%')) | bd! | endif
endfunction
command Rm :call DeleteAndCloseBuffer()

nnoremap <leader>l :nohlsearch<CR>	

" git
nnoremap <leader>G  :Gstatus<CR>

" commands
command Vimrc :e ~/.vimrc
command So :source %
command Reload :source ~/.vimrc

command Ga :!git a %
" au BufNewFile,BufRead .vimrc noremap <leader>f :source %
"
" Neovim terminal mapping
" tnoremap <Esc> <C-\><C-n>
" tnoremap <C-[> <C-\><C-n>

function! SearchFilesByWord(word)
    :execute ":FZF -q " . a:word
endfunction

function! GoToDefaultExport()
    let result = search('export default', '', '')
endfunction

function! GoToDefinitionJS()
    let startingLine=getline('.')
    let word = expand("<cword>")

    if matchstr(startingLine, '^import') != 'import'
        :normal gD
        :set hls
    end

    let currentLine=getline('.')
    let importLine = '[import]*' .'[' . word . ']*[from]'
    let splitted = split(currentLine, "'")
    echo splitted

    let targetFilePath = get(splitted, -1 - 1)
    " let targetFilePath = splitted[-1 - 1]

    " try to jump to definition only if file not npm module
    if matchstr(targetFilePath, "^\.") == '.'
        if splitted[0] =~ importLine
            " try to open file with gf
            try 
                :execute "normal /;/\<CR>"
                :normal 3hgf
                call GoToDefaultExport()
            catch
                " try to open file with :e <filename>*
                try
                    let currentFolder =  expand('%:p:h') 
                    :execute ":e " . currentFolder . '/' . targetFilePath . '*'
                    call GoToDefaultExport()
                catch
                    :normal `` 
                endtry
            finally

            endtry
        else
        end
    " else
        " try
        "     " try to open module from node_modules (works only if vim started
        "     " from project root)
        "     :execute ":e ./node_modules/" . targetFilePath . '*'
        " catch
        "     :normal `` 
        " endtry

    end
:endfunction

augroup javascript
    " au BufNewFile,BufRead *.js noremap gd *:call GoToDefinitionJS()<CR>
    au BufEnter,BufNewFile,BufRead *.js noremap <leader>gd :TernDef<CR>
    au BufEnter,BufNewFile,BufRead *.test.js noremap <leader>t :call TestFile()<CR>
    au BufEnter,BufNewFile,BufRead *.test.js noremap <leader>T :call Test()<CR>
    " au BufNewFile,BufRead *.jsx noremap gd :call GoToDefinitionJS()<CR>
    au BufEnter,BufNewFile,BufRead *.jsx noremap <leader>gd :TernDef<CR>
    au BufEnter,BufNewFile,BufRead *.vue noremap  <leader>gd :call GoToDefinitionJS()<CR>
augroup end
" au BufNewFile,BufRead *.vue noremap  gd :TernDef<CR>
"
augroup php
    au BufEnter,BufNewFile,BufRead *.php noremap  <leader>gd :ALEGoToDefinition<CR>
augroup end

augroup focusevents
    " Reload file if file changed
    au FocusGained,BufEnter * :silent! !
augroup end

command Run :!%
au Filetype sh map <leader>r :Run<CR>

" Run all test
function! Test()
    let currentFiletype = &filetype
    if currentFiletype =~ 'javascript'
       call OpenSplitTerminal('yarn test', 0, 30)
    else
        echo "No test environment configured"
    endif
endfunction
command Test :call Test()

" Test currentfile
function! TestFile()
    let filePath = expand('%:p')
    let currentFiletype = &filetype

    let currentFiletype = &filetype
    if currentFiletype =~ 'javascript'
       " execute ":!yarn test " . filePath
       let command = 'yarn test ' . filePath
       call OpenSplitTerminal(command, 0, 30)
    else
        echo "No test environment configured"
    endif
endfunction
command TestFile :call TestFile()

" args (command, inVertical, widthOrHeight)
function! OpenSplitTerminal(commands, ...)
    " Check if should open in vertical mode
    let l:isVertical = get(a:, 1)
    " If get optional heigh or width
    let l:heightOrWidth = get(a:, 2, 15)

    let l:openingCommand = isVertical ? 'vnew' : 'new'

    execute ":" . heightOrWidth . openingCommand
    call OpenTerminal(a:commands)
    normal G

    let l:windowDirection = isVertical ? 'h' : 'k'
    execute ":wincmd " . windowDirection
endfunction

function! OpenTerminal(commands)
    call termopen(a:commands)
endfunction

function! ChangeTagName()
    let l:newName = input('Rename to: ')

    " get decimal valu of the current character under cursos
	" getline('.') returns the entire line that cursor is sitting on.
	" col('.') returns the column number that the cursor is sitting
	" on.
	" The regular expression \%nc matches a specific given column
	" where n is that column.
	" The '.' regular expression matches exactly one
	" character.

	let dec = char2nr(matchstr(getline('.'), '\%' . col('.') . 'c.'))
    if dec == 60 || dec == 47 
        normal l
    endif

    if dec == 62 
        normal h  
    endif

    let a:cursor_pos_start = getpos(".")

    normal %l

    execute 'normal! "_ciw'.newName
    :call cursor(a:cursor_pos_start[1], a:cursor_pos_start[2])
    execute 'normal! "_ciw'.newName
endfunction
nnoremap <leader>rt :call ChangeTagName()<cr>

nnoremap <Leader>rw :%s/\<<C-r><C-w>\>/

function! ToggleImportsOrientation()
    normal 0

    let l:isSingleLineImport = search('{.*}', '', line('.'))
   
    " All import on single line
    if isSingleLineImport
        execute "normal 0f{a\<CR>"

        let l:matches = searchpos(',', 'z', line("."))
        while l:matches[1] > 0
            execute "normal lxi\<CR>"
            let l:matches = searchpos(',', 'z', line("."))
        endwhile

        execute "normal f}i\<CR>"
    else
        " Imports on multiple lines
        let l:isMultiLineEnd = search('}', '', line('.'))
        let l:isMultiLineStart = search('{', '', line('.'))

        " Move to starting bracket
        if isMultiLineStart
            normal f{
        elseif isMultiLineEnd
            normal f}
        endif

        " Move everything to one line
        normal va{J

        " Trim whitespace before and after brackets
        *s/{\s/{/g
        *s/\s}/}/g

    endif
endfunction
command ToggleImportsOrientation :call ToggleImportsOrientation()

"============================================================================
" Additional plugin settings
"============================================================================

" ======== Git =========
" Gitgutter
let g:gitgutter_terminal_reports_focus=0

" ======== Linting =========
" ** Ale **
"" Set this. Airline will handle the rest.
let g:airline#extensions#ale#enabled = 1

let g:ale_fixers = {
\'javascript': ['eslint'],
\}
let g:ale_linters = {
\'javascript': ['eslint'],
\'php': ['langserver'],
\}

" Dont show error highlights on lines, causes vim to slow down on huge files
let g:ale_set_highlights = 0 

let g:ale_php_langserver_executable=$HOME.'/.dotfiles/vim/bundle/LanguageServer-php-neovim/vendor/bin/php-language-server.php'

" let g:LanguageClient_serverCommands = {
"     \ 'php': ['php-language-server'],
"     \ 'javascript': ['javascript-typescript-stdio'],
"     \ 'javascript.jsx': ['tcp://127.0.0.1:2089'],
"     \ }

" ======== Tags =========
" ** Closetag **
let g:closetag_filenames = "*.html,*.xhtml,*.phtml,*.jsx, *.js, *.blade.php"

" ** MatchTagAlways **
let g:mta_filetypes = {
    \ 'html' : 1,
    \ 'xhtml' : 1,
    \ 'xml' : 1,
    \ 'jinja' : 1,
    \ 'javascript.jsx': 1,
    \ 'blade' : 1
    \}


" ======== Autocomplete =========
" ** Deoplete **
" Enable deocomplete
let g:deoplete#enable_at_startup = 1

let g:deoplete#sources#ternjs#timeout = 1

" Whether to include the types of the completions in the result data. Default: 0
let g:deoplete#sources#ternjs#types = 1

" Whether to include the distance (in scopes for variables, in prototypes for 
" properties) between the completions and the origin position in the result 
" data. Default: 0
let g:deoplete#sources#ternjs#depths = 1

" Whether to include documentation strings (if found) in the result data.
" Default: 0
" let g:deoplete#sources#ternjs#docs = 1

" When on, only completions that match the current word at the given point will
" be returned. Turn this off to get all results, so that you can filter on the 
" client side. Default: 1
let g:deoplete#sources#ternjs#filter = 0

" Whether to use a case-insensitive compare between the current word and 
" potential completions. Default 0
let g:deoplete#sources#ternjs#case_insensitive = 1

" Determines whether the result set will be sorted. Default: 1
let g:deoplete#sources#ternjs#sort = 0

" When disabled, only the text before the given position is considered part of 
" the word. When enabled (the default), the whole variable name that the cursor
" is on will be included. Default: 1
let g:deoplete#sources#ternjs#expand_word_forward = 0

" Whether to ignore the properties of Object.prototype unless they have been 
" spelled out by at least two characters. Default: 1
let g:deoplete#sources#ternjs#omit_object_prototype = 0

" Whether to include JavaScript keywords when completing something that is not 
" a property. Default: 0
let g:deoplete#sources#ternjs#include_keywords = 1

" If completions should be returned when inside a literal. Default: 1
let g:deoplete#sources#ternjs#in_literal = 0

"Add extra filetypes
let g:deoplete#sources#ternjs#filetypes = [
            \ 'jsx',
            \ 'javascript.jsx',
            \ 'vue',
            \ '...'
            \ ]

let g:gutentags_enabled=0
let g:gutentags_cache_dir='~/src/_tags'
let g:gutentags_exclude_project_root=[$HOME.'/.dotfiles']

" ======== Snippets =========
" ** UltiSnips **
let g:UltiSnipsSnippetsDir="~/.dotfiles/vim/custom_snippets"
let g:UltiSnipsSnippetDirectories=['custom_snippets']

" ======== UI =========
" ** Airline **
" Enable the list of buffers
" let g:airline#extensions#tabline#enabled = 1

" Show just the filename
let g:airline#extensions#tabline#fnamemod = ':t'

" ** Nerdtree **
" Fixing the weird symbols instead of folders on some systems
let g:NERDTreeDirArrows=0
" NERDTress File highlighting
" function! NERDTreeHighlightFile(extension, fg, bg, guifg, guibg)
"  exec 'autocmd filetype nerdtree highlight ' . a:extension .' ctermbg='. a:bg .' ctermfg='. a:fg .' guibg='. a:guibg .' guifg='. a:guifg
"  exec 'autocmd filetype nerdtree syn match ' . a:extension .' #^\s\+.*'. a:extension .'$#'
" endfunction

" call NERDTreeHighlightFile('jade', 'green', 'none', 'green', '#151515')
" call NERDTreeHighlightFile('ini', 'yellow', 'none', 'yellow', '#151515')
" call NERDTreeHighlightFile('md', 'blue', 'none', '#3366FF', '#151515')
" call NERDTreeHighlightFile('yml', 'yellow', 'none', 'yellow', '#151515')
" call NERDTreeHighlightFile('config', 'yellow', 'none', 'yellow', '#151515')
" call NERDTreeHighlightFile('conf', 'yellow', 'none', 'yellow', '#151515')
" call NERDTreeHighlightFile('json', 'yellow', 'none', 'yellow', '#151515')
" call NERDTreeHighlightFile('html', 'yellow', 'none', 'yellow', '#151515')
" call NERDTreeHighlightFile('styl', 'cyan', 'none', 'cyan', '#151515')
" call NERDTreeHighlightFile('css', 'cyan', 'none', 'cyan', '#151515')
" call NERDTreeHighlightFile('coffee', 'Red', 'none', 'red', '#151515')
" call NERDTreeHighlightFile('js', 'Red', 'none', '#ffa500', '#151515')
" call NERDTreeHighlightFile('php', 'Magenta', 'none', '#ff00ff', '#151515')
"
"
" Code dark additional colors
" call <sid>hi('jsArguments', s:cdBlue, {}, 'none', {})
" call <sid>hi('jsDomNodeConsts', s:cdGreen, {}, 'none', {})
" call <sid>hi('jsObjectFuncName', s:cdRed, {}, 'none', {})

" call <sid>hi('jsObjectProp', s:cdLightBlue, {}, 'none', {})
" call <sid>hi('jsFuncCall', s:cdYellow, {}, 'none', {})
" call <sid>hi('jsClassDefinition', s:cdBlueGreen, {}, 'none', {})
" call <sid>hi('xmlTag', s:cdGray, {}, 'none', {})
" call <sid>hi('xmlTagName', s:cdBlueGreen, {}, 'none', {})
" call <sid>hi('jsClassKeyword', s:cdBlue, {}, 'none', {})
" call <sid>hi('jsExtendsKeyword', s:cdBlue, {}, 'none', {})


"
"
" if executable('typescript-language-server')
"     au User lsp_setup call lsp#register_server({
"       \ 'name': 'typescript-language-server',
"       \ 'cmd': { server_info->[&shell, &shellcmdflag, 'typescript-language-server --stdio']},
"       \ 'root_uri': { server_info->lsp#utils#path_to_uri(lsp#utils#find_nearest_parent_directory(lsp#utils#get_buffer_path(), '.git/..'))},
"       \ 'whitelist': ['typescript', 'javascript', 'javascript.jsx']
"       \ })
" endif
