"============================================================================
" Plugs
"============================================================================
" load all plugins from under .dotfiles
set rtp+=~/.dotfiles/vim
call plug#begin('~/.dotfiles/vim/bundle')

" General usability
Plug 'scrooloose/nerdtree', { 'on':  ['NERDTreeToggle', 'NERDTreeFind'] }
Plug 'tpope/vim-commentary'           " Comments
Plug 'tpope/vim-surround'             " Vim Surround plugin 
Plug 'jiangmiao/auto-pairs'           " Autoclose brackets
Plug 'alvan/vim-closetag'             " Close HTML, XML tags

" Git
Plug 'tpope/vim-fugitive'             " Git utility
Plug 'airblade/vim-gitgutter'         " Show git diffs on sidebar
Plug 'jreybert/vimagit'

" Languages
Plug 'posva/vim-vue', {'for': 'vue'}
" Plug 'othree/html5.vim', {'for': 'html'}
Plug 'pangloss/vim-javascript', {'for': 'javascript'}
Plug 'mxw/vim-jsx', {'for': 'javascript'}
Plug 'alampros/vim-styled-jsx'
Plug 'jwalton512/vim-blade', {'for': 'blade'}
Plug 'StanAngeloff/php.vim', {'for': 'php'}

Plug 'junegunn/fzf'                   " fuzzy searc

" Lint, autocomplete, etc
Plug 'w0rp/ale'
Plug 'editorconfig/editorconfig-vim'

" Intellisense, code completion, goto definition
Plug 'neoclide/coc.nvim', {'tag': '*', 'do': { -> coc#util#install()}}
" To install php-language-server
Plug '~/.dotfiles/vim/custom-bundle/php-language-server', {'do': 'composer install && composer run-script parse-stubs'}

" Tests
Plug 'janko-m/vim-test'

" Snippets
Plug 'SirVer/ultisnips'

" Themes
Plug 'tomasiser/vim-code-dark'        "Theme based on visual studio code
Plug 'morhetz/gruvbox'


call plug#end()            " required

"============================================================================
"General
"============================================================================
set nocompatible            " no need to support vi
filetype plugin on
filetype indent on
set mouse=a                 " Use mouse
set rtp+=~/.local/bin       " Use executables (fzf) from bin
set path+=**                " Provide tab-completion for all file-related tasks
set autoread                " Reload files changed outside vim
set encoding=utf-8
set nowrap                  " Disable text wrapping"
set backspace=2             " Allow deleting in insert mode 
set scrolloff=8             " keep 8 lines of space above and below the cursor
set splitright              " Split new windows to the right"
set splitbelow              " Split horizontal new windows to the bottom"
" set backupcopy=no          " Doesnt with webpack-dev-server without this (if backups not on)?
set nobackup
set noswapfile              " Dont use swapfiles"
set hidden                  " Can change to another buffer without saving change"
set updatetime=500          " Shows gitgutter signs faster 
set timeout                 " Reduce timeout caused by pressin Esc"
set timeoutlen=3000
set ttimeout
set ttimeoutlen=50
set ttyfast                   "Smoother scrolling"
set lazyredraw              " "Smootherrrr.??
set noeol                   " no new line at the end
set binary                  " No new line at the end

"============================================================================
" UI
"============================================================================
set number					" For line numbering
set wildmenu                " Display all matching files when we tab complete
" set ruler
set noruler
set nocursorline
" set relativenumber          " For relative line numbering
syntax enable				" Show syntax
set t_Co=256                " Enable 256 colors
set t_ut=
" set termguicolors           " Better colors in terminal, needs support from tmux also
"
" colorscheme codedark		" Do not set termguicolors with this one
" colorscheme onedark
" colorscheme plain
colorscheme gruvbox
set background=dark    " Setting dark mode
set showcmd					" Show command at the bottom
" set sidescroll=0            " Faster scrolling

" Custom statusline
" filename (tail of the path), help buffer flag, modified flag,
" function! GetGitBranch()
"     let l:res = system("git rev-parse --abbrev-ref HEAD")
"     return res
" endfunction
" set statusline=%t
" set statusline=%t\ %h%m%=%-10.(%y%)%{GetGitBranch()}

"============================================================================
" Spaces & tab 
"============================================================================
set tabstop=4
set softtabstop=4
set shiftwidth=4			" When indenting with >
set expandtab				" When tabbing, insert (four) spaces

"============================================================================
"Searching
"============================================================================
set grepprg=rg\ --vimgrep    " Use ripgrep instad of grep"
set ignorecase              " When typing smallcase, search is case-insensitive"
set smartcase               " If any character is UPPER-case, search case-sensitive"
set hlsearch                " Highligth search 
set incsearch				" Search as characters are entered


"============================================================================
" Custom Functions
"============================================================================
function! ToggleJSFunctionSyntax()
    let currentLine=getline('.')

    " Check if this is older syntax
    if matchstr(currentLine, "function") == "function"

        " Check if assigned function
        if matchstr(currentLine, "=") == "="
            " Check if var is used, and change it to const
            if matchstr(currentLine, 'var') == "var"
                normal 0ceconst
            endif
            " Change to arrow syntax
            normal 0f=wdt(f)la=> 
        else
            " Not assigned to variable

            let l:functionWordPosition = matchstrpos(currentLine, "function")
            " execute '/\%'.line(".").'lfunction'
            " execute cursor(matchstrpos(currentLine, "function"))
            :call cursor(line("."), functionWordPosition[1] + 1)
            normal ciwconst
            normal f(i = 
            normal f)a =>

            let a:cursosPositionBeforeIndent = getpos(".")
            normal ==
            :call cursor(a:cursosPositionBeforeIndent[1], a:cursosPositionBeforeIndent[2])
        endif
    else
        " Arrow function

        " Check if assigned to variable, const fn = ()
        " The assignment will be removed, just use: function() 
        " TODO: better check
        if matchstr(currentLine, " = ") == " = "
            if matchstr(currentLine, 'const') == "const"  || matchstr(currentLine, 'let') == "let" 
                 normal 0cefunction
                 normal ==
            endif

            " normal 0cevar
            " normal 0f(ifunction
            normal f=hd3l
            normal f)ldf>

        else
            " Not assigned to variable
            normal 0f>F(ifunction
            normal f)ldf>
        endif

    endif

endfunction

function! CommentJsx()
    normal `>o */}
    normal `<O{/*
    normal f}x
endfunction

" Adds inputted character to the end of the line without moving the cursor
function! AppendCharacterToEndOfLine()
    let a:cursor_pos_start = getpos(".")
    let c = nr2char(getchar())
    :execute "keepjumps normal! A".c

    " Move cursor back to original position
    call cursor(a:cursor_pos_start[1], a:cursor_pos_start[2])

endfunction

"============================================================================
"Keybindings, custom mappings
"============================================================================
let mapleader="\<Space>"	" Use space as leader key

nnoremap <leader>w :w<CR>
"Easier copy and paste from system clipboard
nnoremap <leader>Y "*y
vnoremap <leader>Y "*y
nnoremap <leader>P "+p

" map <ScrollWheelUp> <C-Y>
" map <ScrollWheelDown> <C-E>

nnoremap <silent><leader>a :call AppendCharacterToEndOfLine()<cr>

" Save if changes
" noremap <Leader>s :update<CR>	"quicksave

function! ToggleNERDTree()
    let l:isNERDTreeFocused = exists("b:NERDTree")
    if isNERDTreeFocused == 0 && bufexists(expand('%'))
        :NERDTreeFind
    else
        :NERDTreeToggle
    endif
endfunction
nnoremap <leader>e :call ToggleNERDTree()<CR>

let g:UltiSnipsJumpForwardTrigger="<Tab>"
let g:UltiSnipsJumpBackwardTrigger="<S-Tab>"

" Grep from files (current pwd). Seachword is a string, no regex, which allows
" to search for any kind of string inside project
function! Grep(searchword)
    let globs = "-g '!node_modules' -g '!.git/' -g '!*.lock' -g '!vendor/' -g '!storage/debugbar' -g '!_ide_helper.php' "
    :execute "grep! -S --hidden ". globs . "-F " . '"' . a:searchword . '"'
    :execute "cw"
endfunction

function! GrepFromFiles(selection) 
    let name = input('Search for: ', a:selection)
    if name != ""
        :execute ":call Grep(name)"
    endif

:endfunction
nnoremap <leader>f :silent call GrepFromFiles("")<CR>
vnoremap <leader>f y :silent call GrepFromFiles(@")<CR>

" FZF
" function! Fzf()
"     " If pwd is git project, get only the files tracked by git, else use
"     " ripgrep to fetch files
"     call fzf#run({'source': 'git ls-files || rg --files . ', 'window': '30new','sink': 'e'})
" endfunction
" nnoremap <leader>p :call Fzf()<CR>
" nnoremap <leader>p :call fzf#run({'source': 'rg --files . ', 'window': '30new','sink': 'e', 'options': '--ansi --color=dark --preview="cat $FILE {}"'})<CR>
nnoremap <leader>p :call fzf#run({'source': 'rg --files . ', 'window': '30new','sink': 'e'})<CR>
vnoremap <leader>p :call SearchFilesByWord("<C-r><C-w>")<CR>

" Open buffer with FZF
" https://github.com/junegunn/fzf/wiki/Examples-(vim)
function! s:buflist()
  redir => ls
  silent ls
  redir END
  return split(ls, '\n')
endfunction

function! s:bufopen(e)
  execute 'buffer' matchstr(a:e, '^[ 0-9]*')
endfunction

nnoremap <silent> <leader>b :call fzf#run({
\   'source':  reverse(<sid>buflist()),
\   'sink':    function('<sid>bufopen'),
\   'options': '+m',
\   'down':    len(<sid>buflist()) + 2
\ })<CR>

nnoremap <C-`> :term<CR>
"For windows navigation
nnoremap <C-h> <C-w>h	
nnoremap <C-j> <C-w>j
nnoremap <C-k> <C-w>k
nnoremap <C-l> <C-w>l

" Move between tabs
nnoremap ]t :tabn<CR>
nnoremap [t :tabp<CR>

" Move to the previous buffer with 
nnoremap [b :bp<CR>
" Move to the next buffer with 
nnoremap ]b :bn<CR>
" Close buffer
nnoremap <leader>q  :bd<CR>


nmap <silent> [e <Plug>(ale_previous_wrap)
nmap <silent> ]e <Plug>(ale_next_wrap)
" nnoremap <leader>q :bp<bar>sp<bar>bn<bar>bd<CR>. 
" " Move to the previous buffer with 
" nnoremap <S-Tab>  :bp<CR>
" " Move to the next buffer with 
" nnoremap <Tab>    :bn<CR>

"here is a more exotic version of my original Kwbd script
"delete the buffer; keep windows; create a scratch buffer if no buffers left
" function s:Kwbd(kwbdStage)
"   if(a:kwbdStage == 1)
"     if(!buflisted(winbufnr(0)))
"       bd!
"       return
"     endif
"     let s:kwbdBufNum = bufnr("%")
"     let s:kwbdWinNum = winnr()
"     windo call s:Kwbd(2)
"     execute s:kwbdWinNum . 'wincmd w'
"     let s:buflistedLeft = 0
"     let s:bufFinalJump = 0
"     let l:nBufs = bufnr("$")
"     let l:i = 1
"     while(l:i <= l:nBufs)
"       if(l:i != s:kwbdBufNum)
"         if(buflisted(l:i))
"           let s:buflistedLeft = s:buflistedLeft + 1
"         else
"           if(bufexists(l:i) && !strlen(bufname(l:i)) && !s:bufFinalJump)
"             let s:bufFinalJump = l:i
"           endif
"         endif
"       endif
"       let l:i = l:i + 1
"     endwhile
"     if(!s:buflistedLeft)
"       if(s:bufFinalJump)
"         windo if(buflisted(winbufnr(0))) | execute "b! " . s:bufFinalJump | endif
"       else
"         enew
"         let l:newBuf = bufnr("%")
"         windo if(buflisted(winbufnr(0))) | execute "b! " . l:newBuf | endif
"       endif
"       execute s:kwbdWinNum . 'wincmd w'
"     endif
"     if(buflisted(s:kwbdBufNum) || s:kwbdBufNum == bufnr("%"))
"       execute "bd! " . s:kwbdBufNum
"     endif
"     if(!s:buflistedLeft)
"       set buflisted
"       set bufhidden=delete
"       set buftype=
"       setlocal noswapfile
"     endif
"   else
"     if(bufnr("%") == s:kwbdBufNum)
"       let prevbufvar = bufnr("#")
"       if(prevbufvar > 0 && buflisted(prevbufvar) && prevbufvar != s:kwbdBufNum)
"         b #
"       else
"         bn
"       endif
"     endif
"   endif
" endfunction

" command! Kwbd call s:Kwbd(1)
" nnoremap <silent> <leader>q :<C-u>Kwbd<CR>

" Create a mapping (e.g. in your .vimrc) like this:
"nmap <C-W>! <Plug>Kwbd

command Bda silent! :%bdelete

function! DeleteAndCloseBuffer()
    let l:message = "Delete file: " . expand('%')
    let l:confirmation = confirm(message, "&Yes\n&No\n" )
    if confirmation == 1 | call delete(expand('%')) | bd! | endif
endfunction
command Rm :call DeleteAndCloseBuffer()


" git
nnoremap <leader>G  :Magit<CR>

" commands
command Vimrc :e ~/.vimrc
command So :source %
command Reload :source ~/.vimrc

command Ga :!git a %
" au BufNewFile,BufRead .vimrc noremap <leader>f :source %
"
" Neovim terminal mapping
" tnoremap <Esc> <C-\><C-n>
" tnoremap <C-[> <C-\><C-n>

function! SearchFilesByWord(word)
    :execute ":FZF -q " . a:word
endfunction

function! GoToDefaultExport()
    let result = search('export default', '', '')
endfunction

function! GoToDefinitionJS()
    let startingLine=getline('.')
    let word = expand("<cword>")

    if matchstr(startingLine, '^import') != 'import'
        :normal gD
        :set hls
    end

    let currentLine=getline('.')
    let importLine = '[import]*' .'[' . word . ']*[from]'
    let splitted = split(currentLine, "'")
    echo splitted

    let targetFilePath = get(splitted, -1 - 1)
    " let targetFilePath = splitted[-1 - 1]

    " try to jump to definition only if file not npm module
    if matchstr(targetFilePath, "^\.") == '.'
        if splitted[0] =~ importLine
            " try to open file with gf
            try 
                :execute "normal /;/\<CR>"
                :normal 3hgf
                call GoToDefaultExport()
            catch
                " try to open file with :e <filename>*
                try
                    let currentFolder =  expand('%:p:h') 
                    :execute ":e " . currentFolder . '/' . targetFilePath . '*'
                    call GoToDefaultExport()
                catch
                    :normal `` 
                endtry
            finally

            endtry
        else
        end
    " else
        " try
        "     " try to open module from node_modules (works only if vim started
        "     " from project root)
        "     :execute ":e ./node_modules/" . targetFilePath . '*'
        " catch
        "     :normal `` 
        " endtry

    end
endfunction

function! Lint()
    :execute ":!php-cs-fixer fix %"
endfunction
command Lint :call Lint()

augroup javascript
    au!
    " au BufNewFile,BufRead *.js noremap gd *:call GoToDefinitionJS()<CR>
    au BufEnter,BufNewFile,BufRead *.js noremap <leader>gd :TernDef<CR>
    au BufEnter,BufNewFile,BufRead *.test.js noremap <leader>t :call TestFile()<CR>
    au BufEnter,BufNewFile,BufRead *.test.js noremap <leader>T :call Test()<CR>
    " au BufNewFile,BufRead *.jsx noremap gd :call GoToDefinitionJS()<CR>
    au BufEnter,BufNewFile,BufRead *.jsx noremap <leader>gd :TernDef<CR>
    au BufEnter,BufNewFile,BufRead *.vue noremap  <leader>gd :call GoToDefinitionJS()<CR>

    " can help with vue syntax highlight breaking
	" au FileType vue syntax sync fromstart
augroup end
" au BufNewFile,BufRead *.vue noremap  gd :TernDef<CR>
"
augroup php
    au!
    au BufEnter,BufNewFile,BufRead *.php noremap  <leader>gd :ALEGoToDefinition<CR>
augroup end

augroup focusevents
    au!
    " Reload file if file changed
    au FocusGained,BufEnter * :silent! !
augroup end

augroup makefile
    au!
    au BufEnter,BufNewFile,BufRead *.c nnoremap <leader>m :make<CR>
augroup end

command Run :!%
au Filetype sh map <leader>r :Run<CR>

" Run all test
function! Test()
    let currentFiletype = &filetype
    if currentFiletype =~ 'javascript'
       call OpenSplitTerminal('yarn test', 0, 30)
    else
        echo "No test environment configured"
    endif
endfunction
command Test :call Test()

" Test currentfile
function! TestFile()
    let filePath = expand('%:p')
    let currentFiletype = &filetype

    let currentFiletype = &filetype
    if currentFiletype =~ 'javascript'
       " execute ":!yarn test " . filePath
       let command = 'yarn test ' . filePath
       call OpenSplitTerminal(command, 0, 30)
    else
        echo "No test environment configured"
    endif
endfunction
command TestFile :call TestFile()

" args (command, inVertical, widthOrHeight)
function! OpenSplitTerminal(commands, ...)
    " Check if should open in vertical mode
    let l:isVertical = get(a:, 1)
    " If get optional heigh or width
    let l:heightOrWidth = get(a:, 2, 15)

    let l:openingCommand = isVertical ? 'vnew' : 'new'

    execute ":" . heightOrWidth . openingCommand
    call OpenTerminal(a:commands)
    normal G

    let l:windowDirection = isVertical ? 'h' : 'k'
    execute ":wincmd " . windowDirection
endfunction

function! OpenTerminal(commands)
    call termopen(a:commands)
endfunction

function! ChangeTagName()
    let l:newName = input('Rename to: ')

    " get decimal valu of the current character under cursos
	" getline('.') returns the entire line that cursor is sitting on.
	" col('.') returns the column number that the cursor is sitting
	" on.
	" The regular expression \%nc matches a specific given column
	" where n is that column.
	" The '.' regular expression matches exactly one
	" character.

	let dec = char2nr(matchstr(getline('.'), '\%' . col('.') . 'c.'))
    if dec == 60 || dec == 47 
        normal l
    endif

    if dec == 62 
        normal h  
    endif

    let a:cursor_pos_start = getpos(".")

    normal %l

    execute 'normal! "_ciw'.newName
    :call cursor(a:cursor_pos_start[1], a:cursor_pos_start[2])
    execute 'normal! "_ciw'.newName
endfunction
nnoremap <leader>rt :call ChangeTagName()<cr>

nnoremap <Leader>rw :%s/\<<C-r><C-w>\>/

function! ToggleImportsOrientation()
    normal 0

    let l:isSingleLineImport = search('{.*}', '', line('.'))
   
    " All import on single line
    if isSingleLineImport
        execute "normal 0f{a\<CR>"

        let l:matches = searchpos(',', 'z', line("."))
        while l:matches[1] > 0
            execute "normal lxi\<CR>"
            let l:matches = searchpos(',', 'z', line("."))
        endwhile

        execute "normal f}i\<CR>"
    else
        " Imports on multiple lines
        let l:isMultiLineEnd = search('}', '', line('.'))
        let l:isMultiLineStart = search('{', '', line('.'))

        " Move to starting bracket
        if isMultiLineStart
            normal f{
        elseif isMultiLineEnd
            normal f}
        endif

        " Move everything to one line
        normal va{J

        " Trim whitespace before and after brackets
        *s/{\s/{/g
        *s/\s}/}/g

    endif
endfunction
command ToggleImportsOrientation :call ToggleImportsOrientation()

function! ToggleFuncParamOrientation()

    normal 0

    let l:isDefinedInSingle = search('(.*)', '', line('.'))


    " All params on single line
    if isDefinedInSingle
        execute "normal 0f(a\<CR>"

        let l:matches = searchpos(',', 'z', line("."))
        while l:matches[1] > 0
            execute "normal lxi\<CR>"
            let l:matches = searchpos(',', 'z', line("."))
        endwhile

        execute "normal f)i\<CR>"
    else
        " Imports on multiple lines
        let l:isMultiLineEnd = search(')', '', line('.'))
        let l:isMultiLineStart = search('(', '', line('.'))

        " Move to starting bracket
        if isMultiLineStart
            normal f(
        elseif isMultiLineEnd
            normal f)
        endif

        " Move everything to one line
        normal va(J

        " Trim whitespace before and after brackets

        *s/(\s/(/g
        " *s/\s)/)/g

    endif
endfunction
command ToggleFuncParamOrientation :call ToggleFuncParamOrientation()

command -range CommentJsx :call CommentJsx()

"============================================================================
" Additional plugin settings
"============================================================================

" ======== Git =========
" Gitgutter
let g:gitgutter_terminal_reports_focus=0

" ======== Linting =========
let g:ale_fixers = {
\'javascript': ['eslint'],
\'c': ['clang-format']
\}
let g:ale_linters = {
\'javascript': ['eslint'],
\'php': ['langserver'],
\}

" Dont show error highlights on lines, causes vim to slow down on huge files
" let g:ale_set_highlights = 0 

let g:ale_php_langserver_executable=$HOME.'/.dotfiles/vim/bundle/php-language-server/vendor/bin/php-language-server.php'

" ======== Tags =========
" ** Closetag **
let g:closetag_filenames = "*.html,*.xhtml,*.phtml,*.jsx, *.js, *.blade.php, *.vue"

" ** MatchTagAlways **
let g:mta_filetypes = {
    \ 'html' : 1,
    \ 'xhtml' : 1,
    \ 'xml' : 1,
    \ 'jinja' : 1,
    \ 'javascript.jsx': 1,
    \ 'blade' : 1
    \}
" Do dont jump to matching tag on another line
let g:AutoPairsMultilineClose = 0

" ======== Snippets =========
" ** UltiSnips **
let g:UltiSnipsSnippetsDir="~/.dotfiles/vim/custom_snippets"
let g:UltiSnipsSnippetDirectories=['custom_snippets']

" ======== UI =========
" ** Nerdtree **
" Fixing the weird symbols instead of folders on some systems
let g:NERDTreeDirArrows=0